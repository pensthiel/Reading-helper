<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kids Reading Helper</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playwrite+FR+Trad+Guides:wght@400&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #ffffff;
      --fg: #111;
      --muted: #666;
      --accent: #2b8a3e;
      --danger: #c92a2a;
      --card: #f6f6f7;
      --highlight: #fff3bf;
      --col1: #1f7a8c;
      --col2: #9c27b0;
      --col3: #ff7043;
      --col4: #2e7d32;
      --col5: #1565c0;
      --col6: #c2185b;
      --silent: #9aa0a6;
      --sound-fr-ou: #1f7a8c;
      --sound-fr-au: #d97706;
      --sound-fr-en: #16a34a;
      --sound-fr-in: #7c3aed;
      --sound-fr-on: #e11d48;
      --sound-en-oo: #2563eb;
      --sound-en-ee: #f97316;
      --sound-en-th: #ef4444;
      --sound-en-sh: #6366f1;
      --sound-en-ch: #0ea5e9;
      --reader-line-height: 2;
      --reader-letter-spacing: 0.4px;
      --reader-font-sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --reader-font-cursive: "Playwrite FR Trad Guides", cursive;
      --reader-font: var(--reader-font-sans);
    }

    .dark {
      --bg: #0f1115;
      --fg: #f1f3f5;
      --muted: #9aa0a6;
      --accent: #7cd992;
      --danger: #ff6b6b;
      --card: #171a21;
      --highlight: #2a2e39;
      --silent: #6b7280;
      --sound-fr-ou: #4cc9f0;
      --sound-fr-au: #f7a33c;
      --sound-fr-en: #4ade80;
      --sound-fr-in: #a855f7;
      --sound-fr-on: #fb7185;
      --sound-en-oo: #60a5fa;
      --sound-en-ee: #fbbf24;
      --sound-en-th: #f87171;
      --sound-en-sh: #a78bfa;
      --sound-en-ch: #38bdf8;
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial
    }

    .wrap {
      max-width: 980px;
      margin: 0 auto;
      padding: 16px
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap
    }

    h1 {
      font-size: 22px;
      margin: 8px 0
    }

    .card {
      background: var(--card);
      border-radius: 12px;
      padding: 12px;
      margin: 10px 0
    }

    label {
      font-size: 14px;
      color: var(--muted);
      display: block;
      margin: 8px 0 4px
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #0000;
      background: var(--bg);
      color: var(--fg)
    }

    textarea {
      min-height: 140px;
      resize: vertical
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px
    }

    @media(min-width:720px) {
      .row-2 {
        grid-template-columns: 1fr 1fr
      }

      .row-3 {
        grid-template-columns: 1fr 1fr 1fr
      }
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 10px 16px;
      border-radius: 12px;
      border: 1px solid #0000;
      background: var(--accent);
      color: #fff;
      cursor: pointer;
      font-weight: 800;
      text-decoration: none;
      user-select: none
    }

    .btn.primary {
      font-size: 18px;
      padding: 14px 18px;
      box-shadow: 0 4px 14px rgba(0, 0, 0, .12)
    }

    .btn.ghost {
      background: #0000;
      color: var(--fg);
      border: 1px solid var(--muted);
      font-weight: 600
    }

    .btn.secondary {
      background: #3b82f6
    }

    .btn.danger {
      background: var(--danger)
    }

    .btn.sm {
      padding: 6px 10px;
      font-size: 14px;
      border-radius: 10px
    }

    .note {
      font-size: 12px;
      color: var(--muted)
    }

    .error {
      color: var(--danger);
      font-weight: 600
    }

    details.optional {
      border: 1px dashed var(--muted);
      border-radius: 10px;
      padding: 8px;
      background: var(--card)
    }

    details.optional>summary {
      cursor: pointer;
      font-weight: 700
    }

    /* Reader layout */
    #reader {
      display: none;
      margin-top: 8px;
      border-radius: 12px
    }

    .reader-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px
    }

    @media(min-width:900px) {
      .reader-grid {
        grid-template-columns: 320px 1fr;
        align-items: start
      }

      .reader-controls {
        position: sticky;
        top: 8px;
        max-height: 80vh;
        overflow: auto
      }
    }

    @media(max-width:899px) {
      .reader-controls {
        position: sticky;
        top: 0;
        z-index: 5;
        background: var(--card);
        border-radius: 12px;
        padding: 8px
      }
  .app-grid { grid-template-columns: minmax(36px, 10vw) 1fr; }
  #plantCanvas { width: 100%; height: auto; }
    }

    .reader-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      background: var(--card);
      border-radius: 12px
    }

  /* App-wide left dock for plant ribbon */
  .app-grid { display: grid; grid-template-columns: minmax(44px, 6vw) 1fr; gap: 8px; align-items: start; }
  #plantDock { position: sticky; top: 8px; display:flex; flex-direction:column; align-items:center; gap:12px; }
  #plantCanvas { display:block; width: 100%; height: auto; image-rendering: pixelated; }

  #flowerShelf {
    position: fixed;
    bottom: 16px;
    right: 16px;
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
    justify-content: flex-end;
    align-items: flex-end;
    max-width: min(360px, 60vw);
    pointer-events: none;
    z-index: 30;
  }

  .mini-plant {
    position: relative;
    width: 46px;
    height: 72px;
    pointer-events: none;
  }

  .mini-plant .mini-stem {
    position: absolute;
    bottom: 18px;
    left: 50%;
    transform: translateX(-50%);
    width: 6px;
    border-radius: 3px;
    background: var(--mini-stem, #2e7d32);
    height: var(--mini-stem-height, 34px);
  }

  .mini-plant .mini-leaf {
    position: absolute;
    width: 12px;
    height: 7px;
    background: var(--mini-leaf, #3ba261);
    border-radius: 12px 12px 4px 4px;
    bottom: calc(20px + var(--mini-stem-height, 34px) * 0.55);
    opacity: var(--mini-leaf-opacity, 1);
  }

  .mini-plant .mini-leaf.left {
    left: calc(50% - 14px);
    transform: rotate(-18deg);
  }

  .mini-plant .mini-leaf.right {
    right: calc(50% - 14px);
    transform: rotate(18deg);
  }

  .mini-plant .mini-plant-sprite {
    position: absolute;
    bottom: calc(20px + var(--mini-stem-height, 34px) - 6px);
    left: 50%;
    transform: translate(-50%, 0);
    image-rendering: pixelated;
    pointer-events: none;
  }

  .mini-plant .mini-pot {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 30px;
    height: 18px;
    background: linear-gradient(180deg, #c26a2b 0%, #a24f1b 100%);
    border-radius: 6px 6px 4px 4px;
    box-shadow: inset 0 2px 0 rgba(255,255,255,.35);
  }

  .mini-plant .mini-pot::after {
    content: "";
    position: absolute;
    top: -4px;
    left: 3px;
    right: 3px;
    height: 6px;
    border-radius: 4px 4px 2px 2px;
    background: #3b2f26;
    opacity: .55;
  }

  .mini-plant {
    transform-origin: center bottom;
  }

  .mini-plant.pop {
    animation: mini-pop 0.6s ease-out;
  }

  .mini-plant.has-sprite .mini-stem,
  .mini-plant.has-sprite .mini-leaf,
  .mini-plant.has-sprite .mini-pot {
    display: none;
  }

  .mini-plant.has-sprite .mini-plant-sprite {
    bottom: 0;
    transform: translate(-50%, 0);
  }

  @keyframes mini-pop {
    0% { transform: scale(0.85) translateY(10px); }
    55% { transform: scale(1.08) translateY(-6px); }
    100% { transform: scale(1) translateY(0); }
  }

  .mini-plant .sparkle {
    position: absolute;
    left: calc(50% + var(--sparkle-x, 0px));
    bottom: calc(18px + var(--mini-stem-height, 34px) + var(--sparkle-y, 0px));
    width: 4px;
    height: 4px;
    opacity: 0;
    transform: translate(-50%, 0) scale(0.7);
    animation: sparkle-pop 0.9s ease-out forwards;
    filter: drop-shadow(0 0 2px rgba(255,255,255,.8));
  }

  .mini-plant .sparkle::before,
  .mini-plant .sparkle::after {
    content: "";
    position: absolute;
    top: -2px;
    left: 1px;
    width: 2px;
    height: 8px;
    background: rgba(255,255,255,0.92);
    image-rendering: pixelated;
  }

  .mini-plant .sparkle::after {
    transform: rotate(90deg);
  }

  @keyframes sparkle-pop {
    0% { opacity: 0; transform: translate(-50%, -2px) scale(0.6); }
    25% { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -16px) scale(1); }
  }

    .control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      width: 100%
    }

    .pill {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: var(--bg);
      border: 1px solid var(--muted)
    }

    .reader-inner {
      background: var(--card);
      border-radius: 12px;
      padding: 16px;
      font-family: var(--reader-font, var(--reader-font-sans));
      font-size: clamp(22px, 6vw, 34px);
      line-height: var(--reader-line-height, 2);
      letter-spacing: var(--reader-letter-spacing, 0.4px);
      word-spacing: .25em;
      user-select: none;
      -webkit-tap-highlight-color: transparent
    }

    .reader-inner p {
      margin: 0 0 1.2em 0
    }

    .word {
      padding: 4px 6px;
      border-radius: 6px;
      display: inline-block;
      margin: 0 2px
    }

    .word.current {
      background: var(--highlight)
    }

    .hint {
      font-size: 13px;
      background: #0008;
      color: #fff;
      padding: 6px 10px;
      border-radius: 999px;
      position: sticky;
      top: 52px;
      align-self: flex-start;
      display: none
    }

    .ph1 {
      color: var(--col1)
    }

    .ph2 {
      color: var(--col2)
    }

    .ph3 {
      color: var(--col3)
    }

    .ph4 {
      color: var(--col4)
    }

    .ph5 {
      color: var(--col5)
    }

    .ph6 {
      color: var(--col6)
    }

    .silent {
      color: var(--silent)
    }

    .sound-fr-ou {
      color: var(--sound-fr-ou)
    }

    .sound-fr-au {
      color: var(--sound-fr-au)
    }

    .sound-fr-en {
      color: var(--sound-fr-en)
    }

    .sound-fr-in {
      color: var(--sound-fr-in)
    }

    .sound-fr-on {
      color: var(--sound-fr-on)
    }

    .sound-en-oo {
      color: var(--sound-en-oo)
    }

    .sound-en-ee {
      color: var(--sound-en-ee)
    }

    .sound-en-th {
      color: var(--sound-en-th)
    }

    .sound-en-sh {
      color: var(--sound-en-sh)
    }

    .sound-en-ch {
      color: var(--sound-en-ch)
    }

    footer {
      margin: 24px 0 40px;
      text-align: center;
      font-size: 12px;
      color: var(--muted)
    }

    .kbd {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      padding: 2px 6px;
      border: 1px solid var(--muted);
      border-radius: 6px;
      font-size: 12px
    }

    .top-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center
    }

    .top-toggle-group {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .lang-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px
    }

    .lang-toggle .lang-btn {
      border: none;
      background: transparent;
      color: var(--muted);
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color .2s ease, color .2s ease;
    }

    .lang-toggle .lang-btn[aria-pressed="true"] {
      background: var(--accent);
      color: #fff;
    }

    .font-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    /* Only inside TTS Engine section */
    details.optional .row .pill {
      border-radius: 12px;
    }
  </style>
</head>

<body>
  <div class="app-grid">
    <aside id="plantDock" aria-hidden="true">
      <canvas id="plantCanvas" width="80" height="260"></canvas>
    </aside>
    <div class="wrap">
    <header>
      <h1>Kids Reading Helper</h1>
      <div>
        <button id="toggleTheme" class="btn ghost">🌙 Theme</button>
      </div>
    </header>

    <section class="card">
      <h2 style="margin:6px 0 8px;font-size:18px">What this does</h2>
      <p class="note" style="font-size:14px;color:var(--fg)">
        Paste a story or generate one, then build the helper. After reading a word, Tap/click to read it out loud to check your pronunciation, then read the next one.
        Phonics colors + silent letters are highlighted to help with reading.
      </p>
    </section>

    <section class="card">
      <div class="row row-2">
        <div>
          <label for="story">Story text</label>
          <textarea id="story" placeholder="Paste or write your story here..."></textarea>
          <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
            <button id="btnSaveStory" class="btn ghost sm">💾 Save story</button>
            <button id="btnClearStory" class="btn ghost sm">🧹 Clear</button>
          </div>
        </div>

        <div>
          <details class="optional">
            <summary>Optional AI features</summary>
            <div style="margin-top:8px">
              <label>OpenAI API key (for story gen & Whisper)</label>
              <input id="apiKey" type="password" placeholder="OpenAI API key" autocomplete="off" />

              <label for="prompt">Story prompt</label>
              <input id="prompt" type="text" placeholder="Write a fun 150 word story about a friendly dragon" />

              <div class="row row-3">
                <div>
                  <label for="mode">Age or reading level</label>
                  <select id="mode">
                    <option value="age" selected>Age</option>
                    <option value="level">Reading level</option>
                  </select>
                </div>
                <div id="ageWrap">
                  <label for="age">Age</label>
                  <select id="age">
                    <option>4</option>
                    <option>5</option>
                    <option selected>6</option>
                    <option>7</option>
                    <option>8</option>
                    <option>9</option>
                    <option>10</option>
                  </select>
                </div>
                <div id="levelWrap" style="display:none">
                  <label for="level">Level</label>
                  <select id="level">
                    <option selected>Beginner</option>
                    <option>Intermediate</option>
                    <option>Advanced</option>
                  </select>
                </div>
              </div>

              <div style="display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap">
                <label style="display:inline-flex;align-items:center;gap:6px;font-size:13px"><input type="checkbox"
                    id="rememberKey" /> remember key</label>
                <button id="btnGenerateGPT" class="btn secondary sm">🤖 Generate story</button>
              </div>

              <hr style="border:none;border-top:1px solid var(--muted);opacity:.3;margin:12px 0">

              <label style="font-weight:700">Speech check (Whisper)</label>
              <label style="display:inline-flex;align-items:center;gap:8px" class="note">
                <input type="checkbox" id="whisperEnabled"> enable Whisper speech check
              </label>
              <div class="note">When enabled, on tap it records briefly and checks the word. If correct, it skips TTS.
              </div>

              <hr style="border:none;border-top:1px solid var(--muted);opacity:.3;margin:12px 0">

              <label style="font-weight:700">TTS Engine</label>
              <div class="row">
                <label class="pill" style="display:inline-flex;align-items:center;gap:8px">
                  <input type="radio" name="ttsEngine" value="webspeech" checked> Web Speech (browser)
                </label>
                <div class="pill" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                  <label style="display:inline-flex;align-items:center;gap:8px">
                    <input type="radio" name="ttsEngine" value="openai"> OpenAI TTS
                  </label>
                  <input id="openaiTtsModel" type="text" placeholder="OpenAI TTS model (e.g. tts-1)" />
                  <input id="openaiTtsVoice" type="text" placeholder="OpenAI voice (e.g. alloy)" />
                </div>
                <div class="pill" style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                  <label style="display:inline-flex;align-items:center;gap:8px">
                    <input type="radio" name="ttsEngine" value="eleven"> ElevenLabs
                  </label>
                  <input id="elevenKey" type="password" placeholder="ElevenLabs API Key" />
                  <input id="elevenVoice" type="text" placeholder="Voice ID" />
                </div>
                <div class="note">OpenAI/ElevenLabs require keys; leave them blank to use Web Speech.</div>
              </div>
            </div>
          </details>
        </div>
      </div>
    </section>

    <section class="card">
      <div class="top-controls">
        <button id="btnBuildReader" class="btn primary">🔧 Generate Reading Helper</button>
        <button id="btnStartOver" class="btn ghost sm">🔁 Start over</button>
        <button id="btnResetAll" class="btn danger sm">♻️ Reset all</button>
        <div class="top-toggle-group" style="margin-left:auto">
          <div class="pill lang-toggle" id="langToggle" role="group" aria-label="Language">
            <button type="button" class="lang-btn" data-lang="en" aria-pressed="false">English</button>
            <button type="button" class="lang-btn" data-lang="fr" aria-pressed="false">Français</button>
          </div>
          <label class="pill font-toggle">font
            <select id="fontSelect">
              <option value="sans">Clean sans</option>
              <option value="cursive">Cursive</option>
            </select>
          </label>
        </div>
      </div>
      <div id="status" class="note" style="margin-top:6px"></div>

      <div id="reader" class="reader-grid">
        <div>
          <div class="reader-controls">
            <div class="control-row">
              <button id="btnPrev" class="btn ghost sm">◀ Prev</button>
              <button id="btnSpeak" class="btn sm">🔊 Speak</button>
              <button id="btnNext" class="btn ghost sm">Next ▶</button>
              <span class="pill" id="progressPill">0 of 0</span>
            </div>
            <div class="control-row">
              <label class="pill" style="display:inline-flex;align-items:center;gap:6px">
                <input type="checkbox" id="enforceSeq" checked /> lock sequence
              </label>
              <label class="pill" style="display:inline-flex;align-items:center;gap:6px">
                <input type="checkbox" id="hybridPhonics" checked /> hybrid rules
              </label>
              <label class="pill">rate <input type="range" id="rate" min="0.6" max="1.4" step="0.05" value="1"></label>
              <label class="pill">pitch <input type="range" id="pitch" min="0.8" max="1.4" step="0.05"
                  value="1"></label>
            </div>
            <div class="hint" id="tapHint">Tip: tap or click to hear the next word</div>
          </div>
        </div>

        <div class="reader-inner" id="readerText" aria-live="polite"></div>
      </div>
    </section>

    <footer>Open source and made by Lauren Thiel — <a href="https://thiel.page" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, '_blank', 'noopener'); return false;">thiel.page</a></footer>
    </div>
  </div>

  <div id="flowerShelf" aria-hidden="true"></div>

  <script type="module">
    // ------- helpers
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));
  const LS = { story: "krh_story", idx: "krh_index", theme: "krh_theme", key: "krh_key", settings: "krh_settings", lang: "krh_lang", plant: "krh_plant" };
  const state = {
    tokens: [],
    index: 0,
    voices: [],
    lang: "en",
    lockedVoice: null,
    mediaStream: null,
    PHONICS: null,
    plant: null,
    storySignature: "",
    readerFont: "sans",
    lastProgressIndex: -1,
    sentences: [],
    sentenceEnds: []
  };
  const langButtons = () => Array.from(document.querySelectorAll("#langToggle .lang-btn"));
  const VOICE_PREFS = {
    en: [
      { name: "Google UK English Female" },
      { lang: "en-GB" },
      { lang: "en-US" },
      { lang: "en" }
    ],
    fr: [
      { name: "Google français" },
      { lang: "fr-FR" },
      { lang: "fr" }
    ]
  };
  const READER_FONT_KEYS = ["sans", "cursive"];
  function findPreferredVoice(lang, voices) {
    const normalized = (lang === "fr" ? "fr" : "en");
    const prefs = VOICE_PREFS[normalized] || [];
    for (const pref of prefs) {
      if (pref.name) {
        const matchByName = voices.find(v => v.name && v.name.toLowerCase().includes(pref.name.toLowerCase()));
        if (matchByName) return matchByName;
      }
      if (pref.lang) {
        const matchByLang = voices.find(v => v.lang && v.lang.toLowerCase().startsWith(pref.lang.toLowerCase()));
        if (matchByLang) return matchByLang;
      }
    }
    return voices.find(v => v.lang && v.lang.toLowerCase().startsWith(normalized)) || voices[0] || null;
  }

  function applyReaderFont(mode) {
    const key = READER_FONT_KEYS.includes(mode) ? mode : "sans";
    state.readerFont = key;
    const rootStyle = document.documentElement.style;
    rootStyle.setProperty("--reader-font", `var(--reader-font-${key})`);
    rootStyle.setProperty("--reader-line-height", key === "cursive" ? "2.4" : "2");
    rootStyle.setProperty("--reader-letter-spacing", key === "cursive" ? "0px" : "0.4px");
    const sel = $("#fontSelect");
    if (sel && sel.value !== key) sel.value = key;
  }

    const DEFAULT_STORY = `The Unicorn and the Mermaid.


Luna the unicorn trotted to the sea.
She met Mira the mermaid. "Hi!"
A tiny crab did a silly dance. Everyone giggled.
Luna made a sand cake with shiny shells on top.
The cake wobbled, but it looked yummy.

A little sea snail clapped from a rock.
A gull swooped by and splashed in the water.
They shared the cake. The crab had a tiny bite.
"It's delicious!" said Mira. Luna laughed.
They made shell crowns, then watched pink clouds.
"Best day," said Luna.
"See you tomorrow," said Mira. Friends for life.`
      .replace(/^The Unicorn and the Mermaid\s*\n/i, "The Unicorn and the Mermaid\n");

    function computeStorySignature(text) {
      const normalized = (text || "")
        .toLowerCase()
        .replace(/\s+/g, " ")
        .trim();
      return `${normalized.length}:${normalized.slice(0, 120)}`;
    }

    // theme
    if (localStorage.getItem(LS.theme) === "dark") document.documentElement.classList.add("dark");
    $("#toggleTheme").addEventListener("click", () => { document.documentElement.classList.toggle("dark"); localStorage.setItem(LS.theme, document.documentElement.classList.contains("dark") ? "dark" : "light"); });

    // language + lazy-load dictionary
    function syncLangToggle() {
      langButtons().forEach(btn => {
        const isActive = btn.dataset.lang === state.lang;
        btn.setAttribute("aria-pressed", isActive ? "true" : "false");
        btn.classList.toggle("active", isActive);
      });
    }

    async function changeLanguage(nextLang) {
      const target = nextLang === "fr" ? "fr" : "en";
      if (target === state.lang && state.PHONICS) {
        syncLangToggle();
        return;
      }
      state.lang = target;
      localStorage.setItem(LS.lang, state.lang);
      syncLangToggle();
      await loadPhonics(state.lang);
      if ($("#reader").style.display === "block") {
        const text = ($("#story").value || "").trim();
        if (text) buildReader(text, true);
      }
      state.lockedVoice = null;
      populateVoices();
    }

    (async function initLang() {
      const saved = localStorage.getItem(LS.lang);
      state.lang = saved === "fr" ? "fr" : "en";
      syncLangToggle();
      await loadPhonics(state.lang);
      langButtons().forEach(btn => {
        btn.addEventListener("click", async () => {
          const pressed = btn.dataset.lang;
          if (pressed) await changeLanguage(pressed);
        });
      });
    })();

    async function loadPhonics(lang) {
      if (lang === "fr") {
        const mod = await import('./phonics-fr.js');
        state.PHONICS = mod.PHONICS.fr;
      } else {
        const mod = await import('./phonics-en.js');
        state.PHONICS = mod.PHONICS.en;
      }
  await ensureIrregular(lang);
    }

    // mode switch
    $("#mode").addEventListener("change", e => {
      const v = e.target.value;
      $("#ageWrap").style.display = v === "age" ? "" : "none";
      $("#levelWrap").style.display = v === "level" ? "" : "none";
    });

    // boot
    (function () {
      let s = localStorage.getItem(LS.story);
      if (!s || !s.trim()) { s = DEFAULT_STORY; localStorage.setItem(LS.story, s); }
      $("#story").value = s;

      const st = JSON.parse(localStorage.getItem(LS.settings) || "{}");
      if (st.rate) $("#rate").value = st.rate;
      if (st.pitch) $("#pitch").value = st.pitch;
      if (st.enforceSeq !== undefined) $("#enforceSeq").checked = !!st.enforceSeq;
      if (st.hybridPhonics !== undefined) $("#hybridPhonics").checked = !!st.hybridPhonics;
      applyReaderFont(st.readerFont || "sans");
      if (st.whisper) $("#whisperEnabled").checked = !!st.whisper;
      if (st.openaiTtsModel) $("#openaiTtsModel").value = st.openaiTtsModel;
      if (st.openaiTtsVoice) $("#openaiTtsVoice").value = st.openaiTtsVoice;
      if (st.elevenKey) $("#elevenKey").value = st.elevenKey;
      if (st.elevenVoice) $("#elevenVoice").value = st.elevenVoice;

      const k = localStorage.getItem(LS.key);
      if (k) { $("#apiKey").value = k; $("#rememberKey").checked = true; }

      setStatus("Story ready. Tap Generate Reading Helper to start.");
    })();

    // remember key
    $("#rememberKey").addEventListener("change", e => { if (e.target.checked) { localStorage.setItem(LS.key, $("#apiKey").value); } else { localStorage.removeItem(LS.key); } });
    $("#apiKey").addEventListener("input", () => { if ($("#rememberKey").checked) localStorage.setItem(LS.key, $("#apiKey").value); });

    // save/reset story
    $("#btnSaveStory").addEventListener("click", () => { localStorage.setItem(LS.story, $("#story").value.trim()); setStatus("Story saved."); });
    $("#btnClearStory").addEventListener("click", () => { $("#story").value = ""; setStatus("Cleared."); });

    // TTS engine selection
    $$('input[name="ttsEngine"]').forEach(r => r.addEventListener('change', saveSettings));
    $("#openaiTtsModel").addEventListener("change", saveSettings);
    $("#openaiTtsVoice").addEventListener("change", saveSettings);
    $("#elevenKey").addEventListener("change", saveSettings);
    $("#elevenVoice").addEventListener("change", saveSettings);
    $("#hybridPhonics").addEventListener("change", () => {
      saveSettings();
      if (state.tokens.length) { // rebuild to reapply rules instantly
        const text = ("#story" in window ? $("#story").value : "") || "";
        if (text.trim()) buildReader(text, true);
      }
    });
    $("#whisperEnabled").addEventListener("change", async (e) => {
      saveSettings();
      if (e.target.checked) {
        try {
          await navigator.mediaDevices.getUserMedia({ audio: true });
          setStatus("Mic ready for Whisper.");
        } catch {
          e.target.checked = false;
          saveSettings();
          setError("Mic permission denied.");
        }
      }
    });

    // GPT story gen
    $("#btnGenerateGPT").addEventListener("click", async () => {
      const key = $("#apiKey").value.trim(); if (!key) return setError("Enter API key.");
      const prompt = ($("#prompt").value.trim() || "Write a simple 150 word story for a young child.");
      const mode = $("#mode").value, age = $("#age").value, level = $("#level").value, lang = state.lang || "en";
      const guidance = mode === "age" ? `Target age ${age}. Short sentences. Simple vocabulary.` : `Reading level ${level}. Short sentences. Simple vocabulary.`;
      const langNote = lang === "fr" ? "Write in French." : "Write in English.";
      try {
        setStatus("Generating...");
        const body = {
          model: "gpt-4o-mini", messages: [
            { role: "system", content: "You write child friendly stories with simple vocabulary and short sentences." },
            { role: "user", content: `${langNote}\n${prompt}\n\nConstraints: ${guidance}\nLength: about 150 words.` }
          ], temperature: 0.8
        };
        const res = await fetch("https://api.openai.com/v1/chat/completions", { method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Bearer ${key}` }, body: JSON.stringify(body) });
        if (!res.ok) { throw new Error(await res.text()); }
        const data = await res.json();
        const text = data.choices?.[0]?.message?.content?.trim(); if (!text) throw new Error("No text returned.");
        $("#story").value = text; localStorage.setItem(LS.story, text); setStatus("Story generated.");
      } catch (err) { setError(err.message || String(err)); }
    });

    // Build reader
    $("#btnBuildReader").addEventListener("click", () => {
      const text = ($("#story").value || "").trim(); if (!text) return setError("Add or generate a story first.");
      buildReader(text);
      $("#reader").style.display = "block";
      $("#reader").scrollIntoView({ behavior: "smooth", block: "start" });
    });

    $("#btnStartOver").addEventListener("click", () => { state.index = 0; updateHighlight(); saveProgress(); });
    $("#btnResetAll").addEventListener("click", () => {
      if (!confirm("Reset everything")) return;
      localStorage.removeItem(LS.story); localStorage.removeItem(LS.idx); localStorage.removeItem(LS.settings); localStorage.removeItem(LS.plant);
      state.plant = defaultPlantState("");
      updateFlowerShelf();
      drawPlantRibbon();
      $("#story").value = ""; $("#readerText").innerHTML = ""; $("#reader").style.display = "none"; setStatus("All cleared.");
    });

    $("#btnPrev").addEventListener("click", () => manualStep(-1));
    $("#btnNext").addEventListener("click", () => manualStep(1));
    $("#btnSpeak").addEventListener("click", () => speakWord(state.tokens[state.index]?.speak, () => { }));

    $("#rate").addEventListener("input", saveSettings);
    $("#pitch").addEventListener("input", saveSettings);
    $("#enforceSeq").addEventListener("change", saveSettings);
    $("#fontSelect").addEventListener("change", (e) => { applyReaderFont(e.target.value); saveSettings(); });
    window.addEventListener("keydown", e => {
      if ($("#reader").style.display !== "block") return;
      if (e.code === "Space") { e.preventDefault(); advanceWithCheck(); }
      if (e.code === "ArrowRight") { e.preventDefault(); manualStep(1); }
      if (e.code === "ArrowLeft") { e.preventDefault(); manualStep(-1); }
    });

    // voices (auto-pick based on language)
    function populateVoices() {
      if (!("speechSynthesis" in window)) return;
      const voices = speechSynthesis.getVoices().filter(v => v.lang);
      if (!voices.length) return;
      state.voices = voices;
      const chosen = findPreferredVoice(state.lang, voices);
      if (chosen) state.lockedVoice = chosen;
    }
    if ("speechSynthesis" in window) { speechSynthesis.onvoiceschanged = populateVoices; populateVoices(); }

    // ---------------- Reader build with sentence breaks + phonics markup (dictionary-driven) ----------------
    function buildReader(text, keepIndex = false) {
      localStorage.setItem(LS.story, text);
      const container = $("#readerText"); container.innerHTML = "";
      const paras = splitParagraphs(text);
      const tokens = [];
      const sentenceWordCounts = [];
      const sentenceEnds = [];
      let globalIndex = 0;

      paras.forEach((para, pi) => {
        if (!para.trim()) return;
        const p = document.createElement("p");

        const sentences = splitSentences(para);
        sentences.forEach((sent, si) => {
          const words = sent.split(/\s+/).filter(Boolean);
          words.forEach((raw) => {
            const display = raw;
            const speak = stripPunct(raw);
            const wordSpan = document.createElement("span");
            wordSpan.className = "word";
            wordSpan.dataset.i = String(globalIndex);
            wordSpan.innerHTML = phonicsMarkup(display);
            p.appendChild(wordSpan);
            p.append(" ");
            tokens.push({ display, speak });
            globalIndex++;
          });
          if (words.length) {
            sentenceWordCounts.push(words.length);
            sentenceEnds.push(globalIndex - 1);
          }
          if (si < sentences.length - 1) p.appendChild(document.createElement("br"));
        });

        container.appendChild(p);
      });

  state.tokens = tokens;
      state.sentences = sentenceWordCounts;
      state.sentenceEnds = sentenceEnds;
      const savedIdx = parseInt(localStorage.getItem(LS.idx) || "0", 10);
      state.index = keepIndex ? clamp(savedIdx, 0, state.tokens.length - 1) : (isNaN(savedIdx) ? 0 : clamp(savedIdx, 0, state.tokens.length - 1));
      updateHighlight();
      state.storySignature = computeStorySignature(text);
      initPlantRibbon(state.storySignature, sentenceWordCounts);

      container.onclick = (e) => {
        const enforce = $("#enforceSeq").checked;
        $("#tapHint").style.display = "none";
        if (!enforce) {
          const w = e.target.closest(".word");
          if (w) { state.index = clamp(parseInt(w.dataset.i, 10), 0, state.tokens.length - 1); advanceWithCheck(true); }
          return;
        }
        advanceWithCheck();
      };

      $("#tapHint").style.display = "inline-block";
      setStatus("Reader ready. Tap or click anywhere in the text.");
      $("#progressPill").textContent = `${state.index + 1} of ${state.tokens.length}`;

    }

    function splitParagraphs(text) { return text.replace(/\r/g, '').split(/\n\s*\n/); }
    function splitSentences(para) {
      const out = []; let cur = "";
      for (let i = 0; i < para.length; i++) {
        const ch = para[i];
        cur += ch;
        if (/[.!?]/.test(ch) || ch === "…") {
          const next = para[i + 1] || "";
          if (next === " " || next === "\n" || i === para.length - 1) {
            out.push(cur.trim()); cur = "";
          }
        }
      }
      if (cur.trim()) out.push(cur.trim());
      return out;
    }
    function stripPunct(w) {
      const core = w.replace(/^[^\p{L}\p{N}']+|[^\p{L}\p{N}']+$/gu, "");
      return core.replace(/(?!^)[^\p{L}\p{N}']+/gu, "");
    }

    // --- phonics markup: hybrid (rules + irregular dictionary + explicit list)
    let IRREG_FR = null; let IRREG_EN = null;
    async function ensureIrregular(lang) {
      if (lang === 'fr' && !IRREG_FR) {
        try { const mod = await import('./irregular-fr.js'); IRREG_FR = mod.IRREGULAR_FR; } catch { IRREG_FR = {}; }
      } else if (lang === 'en' && !IRREG_EN) {
        try { const mod = await import('./irregular-en.js'); IRREG_EN = mod.IRREGULAR_EN; } catch { IRREG_EN = {}; }
      }
    }
    function phonicsMarkup(word) {
      const rules = state.PHONICS; // { colored: [...], silentWords: {...} }
      const leading = (word.match(/^[^\p{L}\p{N}]+/u) || [""])[0];
      const trailing = (word.match(/[^\p{L}\p{N}]+$/u) || [""])[0];
      const core = word.slice(leading.length, word.length - trailing.length);
      if (!core) return escapeHtml(word);

      const chars = Array.from(core);

      // Build letter-only normalization for dictionary key
      const letterIdx = [];
      let normLetters = "";
      for (let i = 0; i < chars.length; i++) {
        const ch = chars[i];
        if (/\p{L}/u.test(ch)) {
          const base = ch.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
          letterIdx.push(i);
          normLetters += base;
        }
      }
      const key = normLetters;

      const silentSet = new Set();

      // 1. Explicit per-language dictionary (existing file)
      const explicit = rules?.silentWords?.[key];
      if (explicit) {
        if (Array.isArray(explicit)) explicit.forEach(pos => { const orig = letterIdx[pos]; if (orig != null) silentSet.add(orig); });
        else if (typeof explicit === 'string') {
          for (let i = 0; i < explicit.length; i++) { const orig = letterIdx[i]; if (orig != null) silentSet.add(orig); }
        }
      }

      const hybrid = document.getElementById('hybridPhonics')?.checked;
      if (hybrid) {
        // 2. Irregular large list (asynchronous module) – already loaded previously in loadPhonics or lazily
        const irrMap = state.lang === 'fr' ? (IRREG_FR || {}) : (IRREG_EN || {});
        const irr = irrMap[key];
        if (irr) irr.forEach(pos => { const orig = letterIdx[pos]; if (orig != null) silentSet.add(orig); });

        // 3. Rule-based heuristics (kept conservative to reduce false positives)
        // Apply only if not already marked by explicit dict / irregulars.
        const L = key.length;
        // Common: silent final e (English) / mute e (French) when more than 1 letter and not 'le' pattern short word in English.
        if (L > 1 && key.endsWith('e')) {
          const pos = letterIdx.length - 1; const orig = letterIdx[pos];
            // avoid marking 'le', 'de', 'ce' alone to reduce noise
            if (orig != null && !silentSet.has(orig) && !/^([cdl]e)$/.test(key)) silentSet.add(orig);
        }
        // French: verb endings -ent (all silent) if length > 3 and not already handled
        if (state.lang === 'fr' && key.endsWith('ent') && L > 3) {
          ['e','n','t'].forEach((_,i)=>{ const pos = letterIdx.length - 3 + i; const orig = letterIdx[pos]; if (orig!=null) silentSet.add(orig); });
        }
        // Both: plural -s usually silent in French, sometimes in English (but we skip English generic to avoid errors)
        if (state.lang === 'fr' && key.endsWith('s') && L > 1) {
          const orig = letterIdx[letterIdx.length -1]; if (orig!=null && !silentSet.has(orig)) silentSet.add(orig);
        }
        // French: final consonant after nasal vowel (an/en/in/on/un) often silent (d,t,p,g,x,s) – conservative subset
        if (state.lang === 'fr') {
          if (/(an|en|in|on|un)[dtpgxs]$/.test(key)) {
            const orig = letterIdx[letterIdx.length -1]; if (orig!=null) silentSet.add(orig);
          }
        }
        // English: GH after vowel and before word end or t (already covered by dict but fallback rule)
        if (state.lang === 'en' && /[aeiou]gh(t)?$/.test(key)) {
          const gPos = key.lastIndexOf('g');
          const hPos = key.lastIndexOf('h');
          if (gPos>=0 && hPos===gPos+1) {
            const origG = letterIdx[gPos]; const origH = letterIdx[hPos];
            if (origG!=null) silentSet.add(origG); if (origH!=null) silentSet.add(origH);
          }
        }
      }

      // Colored phonics digraphs/trigraphs (now supports dynamic soundGroups -> consistent colors per phoneme)
      const colorPlan = new Array(chars.length).fill(null);
      const patterns = [];
      if (rules?.colored) {
        patterns.push(...rules.colored);
      }
      if (rules?.soundGroups) {
        const palette = rules.soundPalette || {};
        const fallback = new Map();
        let fallbackIdx = 0;
        Object.entries(rules.soundGroups).forEach(([sound, spellings]) => {
          if (!Array.isArray(spellings)) return;
          const assigned = palette[sound];
          if (!assigned && !fallback.has(sound)) {
            fallback.set(sound, `ph${(fallbackIdx % 12) + 1}`);
            fallbackIdx++;
          }
          const cls = assigned || fallback.get(sound);
          spellings.forEach((gr) => {
            if (!gr) return;
            const norm = gr.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
            patterns.push({ match: norm, cls });
          });
        });
      }
      patterns.sort((a,b)=> b.match.length - a.match.length);
      for (let i = 0; i < chars.length; i++) {
        for (const pat of patterns) {
          const ml = pat.match.length;
          if (i + ml > chars.length) continue;
          const slice = chars.slice(i, i + ml).join("");
          const norm = slice.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase();
          if (norm === pat.match) {
            for (let k = 0; k < ml; k++) {
              if (colorPlan[i + k] == null) colorPlan[i + k] = pat.cls;
            }
          }
        }
      }

      // Build HTML
      let html = "";
      for (let i = 0; i < chars.length; i++) {
        const ch = chars[i];
        const cls = silentSet.has(i) ? "silent" : colorPlan[i];
        if (cls) html += `<span class="${cls}">${escapeHtml(ch)}</span>`;
        else html += escapeHtml(ch);
      }
      return escapeHtml(leading) + html + escapeHtml(trailing);
    }

    function escapeHtml(s) { return s.replace(/[&<>]/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[c])); }

    function updateHighlight() {
      $$(".word").forEach(el => el.classList.remove("current"));
      const el = $(`.word[data-i="${state.index}"]`);
      if (el) el.classList.add("current");
      $("#progressPill").textContent = `${state.index + 1} of ${state.tokens.length}`;
      el?.scrollIntoView({ block: "center", behavior: "smooth" });
    }

    function manualStep(dir) {
      if (!state.tokens.length) return;
      if (dir > 0) { advanceWithCheck(); }
      else {
        if (state.index > 0) { state.index--; updateHighlight(); saveProgress(); }
      }
    }

    async function advanceWithCheck() {
      const token = state.tokens[state.index]; if (!token) return;
      const whisperOn = $("#whisperEnabled").checked;
      if (whisperOn) {
        try {
          const ok = await checkPronunciation(token.speak);
          if (ok) { stepForward(); return; }
        } catch (err) { setError("Whisper check failed. Speaking the word."); }
      }
      speakWord(token.speak, stepForward);
    }

    function stepForward() {
      if (!state.tokens.length) return;
      const justRead = state.index;
      if (state.index < state.tokens.length - 1) state.index++;
      updateHighlight(); saveProgress();
      recordWordProgress(justRead);
    }

    // ---------- TTS ----------
    function pickPreferredLang() { return state.lang === "fr" ? "fr" : "en"; }
    function speakWord(text, after) {
      const engine = document.querySelector('input[name="ttsEngine"]:checked').value;
      if (engine === 'openai') return speakWithOpenAI(text, after);
      if (engine === 'eleven') return speakWithElevenLabs(text, after);
      return speakWithWebSpeech(text, after);
    }
    function speakWithWebSpeech(text, after) {
      if (!("speechSynthesis" in window)) { setError("No Web Speech support."); return; }
      speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.rate = parseFloat($("#rate").value || "1"); u.pitch = parseFloat($("#pitch").value || "1");
      if (!state.lockedVoice) {
        state.lockedVoice = findPreferredVoice(state.lang, state.voices);
      }
      if (state.lockedVoice) u.voice = state.lockedVoice;
      u.onend = () => after && after(); u.onerror = () => setError("TTS failed.");
      speechSynthesis.speak(u);
    }
    async function speakWithOpenAI(text, after) {
      const key = $("#apiKey").value.trim(); if (!key) { setError("OpenAI key required for OpenAI TTS."); return speakWithWebSpeech(text, after); }
      const model = ($("#openaiTtsModel").value.trim() || "tts-1");
      const voice = ($("#openaiTtsVoice").value.trim() || "alloy");
      try {
        setStatus("OpenAI TTS…");
        const res = await fetch("https://api.openai.com/v1/audio/speech", {
          method: "POST",
          headers: { "Authorization": `Bearer ${key}`, "Content-Type": "application/json" },
          body: JSON.stringify({ model, voice, input: text })
        });
        if (!res.ok) throw new Error(await res.text());
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        audio.onended = () => { URL.revokeObjectURL(url); after && after(); };
        audio.onerror = () => { setError("OpenAI TTS audio failed."); };
        audio.play();
      } catch (e) { setError("OpenAI TTS failed. Using Web Speech."); speakWithWebSpeech(text, after); }
    }
    async function speakWithElevenLabs(text, after) {
      const key = $("#elevenKey").value.trim(); const voice = $("#elevenVoice").value.trim();
      if (!key || !voice) { setError("ElevenLabs key and voice required."); return speakWithWebSpeech(text, after); }
      try {
        setStatus("ElevenLabs TTS…");
        const res = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voice}`, {
          method: "POST",
          headers: { "xi-api-key": key, "Content-Type": "application/json" },
          body: JSON.stringify({ text, model_id: "eleven_monolingual_v1", voice_settings: { stability: 0.5, similarity_boost: 0.7 } })
        });
        if (!res.ok) throw new Error(await res.text());
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const audio = new Audio(url);
        audio.onended = () => { URL.revokeObjectURL(url); after && after(); };
        audio.onerror = () => { setError("ElevenLabs audio failed."); };
        audio.play();
      } catch (e) { setError("ElevenLabs TTS failed. Using Web Speech."); speakWithWebSpeech(text, after); }
    }

    // Whisper speech check (OpenAI)
    async function checkPronunciation(expected) {
      const key = $("#apiKey").value.trim();
      if (!key) { setError("No API key for Whisper."); return false; }
      const stream = await getMic(); if (!stream) { setError("Mic permission denied."); return false; }
      setStatus('Listening… say: "' + expected + '"');
      const blob = await recordShort(stream, 1600);
      setStatus("Checking…");
      try {
        const form = new FormData();
        form.append("file", new File([blob], "speech.webm", { type: blob.type || "audio/webm" }));
        form.append("model", "whisper-1");
        form.append("language", pickPreferredLang());
        const res = await fetch("https://api.openai.com/v1/audio/transcriptions", {
          method: "POST",
          headers: { "Authorization": `Bearer ${key}` },
          body: form
        });
        if (!res.ok) { throw new Error(await res.text()); }
        const data = await res.json();
        const heard = (data.text || "").trim();
        const ok = fuzzyMatch(expected, heard);
        setStatus(ok ? `✔ Heard: "${heard}"` : `✖ Heard: "${heard}"`);
        return ok;
      } catch (err) {
        setError("Whisper error: " + (err.message || String(err)));
        return false;
      }
    }

    function normalize(s) {
      return (s || "")
        .toLowerCase()
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-z0-9]/g, "");
    }
    function fuzzyMatch(expected, heard) {
      const a = normalize(expected);
      const b = normalize(heard);
      if (!a || !b) return false;
      if (a === b) return true;
      if (b.includes(a) || a.includes(b)) return true;
      return lev(a, b) <= 1;
    }
    function lev(a, b) {
      const m = a.length, n = b.length;
      const dp = Array.from({ length: m + 1 }, (_, i) => Array(n + 1).fill(0));
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
        }
      }
      return dp[m][n];
    }

    async function getMic() {
      try {
        if (!state.mediaStream) {
          state.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        }
        return state.mediaStream;
      } catch (e) { return null; }
    }
    function recordShort(stream, durMs = 1500) {
      return new Promise((resolve, reject) => {
        const rec = new MediaRecorder(stream);
        const chunks = [];
        rec.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
        rec.onerror = e => reject(e.error || new Error("Recorder error"));
        rec.onstop = () => resolve(new Blob(chunks, { type: chunks[0]?.type || "audio/webm" }));
        rec.start();
        setTimeout(() => { try { rec.stop(); } catch { } }, durMs);
      });
    }

    function saveProgress() { localStorage.setItem(LS.idx, String(state.index)); }
    function saveSettings() {
      localStorage.setItem(LS.settings, JSON.stringify({
        rate: $("#rate").value,
        pitch: $("#pitch").value,
        enforceSeq: $("#enforceSeq").checked,
        hybridPhonics: $("#hybridPhonics").checked,
        readerFont: $("#fontSelect").value,
        whisper: $("#whisperEnabled").checked,
        openaiTtsModel: $("#openaiTtsModel").value,
        openaiTtsVoice: $("#openaiTtsVoice").value,
        elevenKey: $("#elevenKey").value,
        elevenVoice: $("#elevenVoice").value
      }));
    }
    function setStatus(m) { const s = $("#status"); s.className = "note"; s.textContent = m; }
    function setError(m) { const s = $("#status"); s.className = "note error"; s.textContent = m; }
    function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

    // prevent iOS double tap zoom
    let lastTap = 0;
    document.addEventListener("touchend", e => { const now = Date.now(); if (now - lastTap < 350) e.preventDefault(); lastTap = now; }, { passive: false });

    // preload voices early
    if ("speechSynthesis" in window) { speechSynthesis.onvoiceschanged = populateVoices; populateVoices(); }

    // ---------------- Plant ribbon (sentence-based growth + shelf) ----------------
    const PLANT_COLORS = {
      stem: "#2e7d32",
      leaf: "#388e3c",
      seed1: "#6d4c41",
      seed2: "#8d6e63",
      center: "#ffeb3b",
      bud: "#94a3b8",
      flowers: ["#d81b60", "#8e24aa", "#1e88e5", "#43a047", "#fb8c00", "#e53935", "#3949ab"]
    };

    const FLOWER_SHAPES = [
      { size: 3, offsets: [[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1]] },
      { size: 5, offsets: [[0, 0], [1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]] },
      { size: 5, offsets: [[0, 0], [0, 1], [0, -1], [0, 2], [0, -2], [1, 0], [-1, 0], [2, 0], [-2, 0]] },
      { size: 5, offsets: [[0, 0], [1, 0], [-1, 0], [2, 0], [-2, 0], [0, 1], [0, -1], [1, 2], [-1, 2], [1, -2], [-1, -2]] }
    ];
    const PLANT_LIMITS = { maxShelf: 18 };

    function clampColorIdx(idx) {
      const total = PLANT_COLORS.flowers.length || 1;
      const base = Number.isFinite(idx) ? idx : 0;
      return ((base % total) + total) % total;
    }

    function computeSentencesKey(sentences) {
      return Array.isArray(sentences) ? sentences.join(";") : "";
    }

    function defaultPlantState(signature, sentences = []) {
      const key = computeSentencesKey(sentences);
      return {
        storyKey: signature || "",
        sentencesKey: key,
        sentenceIdx: 0,
        progress: 0,
        target: Math.max(1, sentences[0] || 1),
        completed: [],
        colorIdx: 0,
        shapeSeed: Math.floor(Math.random() * FLOWER_SHAPES.length),
        wordsSeen: 0,
        pendingBloom: false,
        sentences: sentences.slice()
      };
    }

    function normalizeSnapshot(entry) {
      if (!entry || typeof entry !== "object") return null;
      const base = {
        colorIdx: clampColorIdx(entry.colorIdx ?? 0),
        shapeIdx: entry.shapeIdx ?? 0,
        stem: Math.max(20, Math.min(60, Number(entry.stem) || 34)),
        leavesOpacity: entry.leavesOpacity != null ? Math.max(0, Math.min(1, Number(entry.leavesOpacity))) : 1,
        sprite: entry.sprite && entry.sprite.url ? entry.sprite : null,
        spriteFull: entry.spriteFull && entry.spriteFull.url ? entry.spriteFull : null
      };
      if (!base.sprite) base.sprite = createFlowerSprite(base.shapeIdx, base.colorIdx);
      return base;
    }

    function getPlantState(signature, sentences = []) {
      const def = defaultPlantState(signature, sentences);
      try {
        const raw = JSON.parse(localStorage.getItem(LS.plant) || "{}");
        if (!raw || typeof raw !== "object") return def;
        if (raw.storyKey !== signature || raw.sentencesKey !== computeSentencesKey(sentences)) return def;
        const completed = Array.isArray(raw.completed)
          ? raw.completed.map(normalizeSnapshot).filter(Boolean).slice(-PLANT_LIMITS.maxShelf)
          : [];
        return {
          storyKey: signature,
          sentencesKey: raw.sentencesKey,
          sentenceIdx: Math.max(0, Number(raw.sentenceIdx) || 0),
          progress: Math.max(0, Number(raw.progress) || 0),
          target: Math.max(1, Number(raw.target) || 1),
          completed,
          colorIdx: clampColorIdx(raw.colorIdx),
          shapeSeed: Number.isFinite(raw.shapeSeed) ? raw.shapeSeed : def.shapeSeed,
          wordsSeen: Math.max(0, Number(raw.wordsSeen) || 0),
          pendingBloom: false,
          sentences: sentences.slice()
        };
      } catch {
        return def;
      }
    }

    function savePlantState() {
      if (!state.plant) return;
      localStorage.setItem(LS.plant, JSON.stringify({
        storyKey: state.plant.storyKey,
        sentencesKey: state.plant.sentencesKey,
        sentenceIdx: state.plant.sentenceIdx,
        progress: state.plant.progress,
        target: state.plant.target,
        completed: state.plant.completed,
        colorIdx: state.plant.colorIdx,
        shapeSeed: state.plant.shapeSeed,
        wordsSeen: state.plant.wordsSeen
      }));
    }

    function initPlantRibbon(signature, sentences = []) {
      state.plant = getPlantState(signature, sentences);
      state.plant.sentences = sentences.slice();
      const key = computeSentencesKey(sentences);
      if (!state.plant || state.plant.storyKey !== signature || state.plant.sentencesKey !== key) {
        state.plant = defaultPlantState(signature, sentences);
      }
      state.plant.sentencesKey = key;
      if (state.plant.sentenceIdx >= sentences.length) {
        state.plant.sentenceIdx = sentences.length;
        state.plant.progress = 0;
      }
      state.plant.target = Math.max(1, sentences[state.plant.sentenceIdx] || 1);
      state.plant.progress = Math.min(state.plant.progress || 0, state.plant.target);
      state.lastProgressIndex = Math.max(-1, (state.plant.wordsSeen || 0) - 1);
      resizePlantCanvas();
      updateFlowerShelf();
      drawPlantRibbon();
      savePlantState();
    }

    function getCurrentShapeIdx() {
      if (!state.plant) return 0;
      return (state.plant.shapeSeed + state.plant.completed.length) % FLOWER_SHAPES.length;
    }

    function drawShapePixels(ctx, centerX, centerY, cell, shapeIdx, color) {
      const shape = FLOWER_SHAPES[shapeIdx % FLOWER_SHAPES.length];
      ctx.fillStyle = color;
      shape.offsets.forEach(([dx, dy]) => {
        const x = centerX + dx * cell;
        const y = centerY - dy * cell;
        ctx.fillRect(x, y, cell, cell);
      });
      ctx.fillStyle = PLANT_COLORS.center;
      ctx.fillRect(centerX, centerY, cell, cell);
    }

    function createFlowerSprite(shapeIdx, colorIdx) {
      const shape = FLOWER_SHAPES[shapeIdx % FLOWER_SHAPES.length];
      const canvas = document.createElement("canvas");
      canvas.width = shape.size;
      canvas.height = shape.size;
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = false;
      const color = PLANT_COLORS.flowers[colorIdx] || PLANT_COLORS.flowers[0];
      const center = Math.floor(shape.size / 2);
      ctx.fillStyle = color;
      shape.offsets.forEach(([dx, dy]) => {
        const tx = center + dx;
        const ty = center - dy;
        ctx.fillRect(tx, ty, 1, 1);
      });
    ctx.fillStyle = PLANT_COLORS.center;
    ctx.fillRect(center, center, 1, 1);
    return { url: canvas.toDataURL("image/png"), size: shape.size };
  }

  function capturePlantSnapshot() {
    const canvas = document.getElementById('plantCanvas');
    if (!canvas) return null;
    const dpr = window.devicePixelRatio || 1;
    const cropWidth = Math.min(canvas.width, Math.round(60 * dpr));
    const cropHeight = Math.min(canvas.height, Math.round(120 * dpr));
    const sx = Math.max(0, Math.round(canvas.width / 2 - cropWidth / 2));
    const sy = Math.max(0, canvas.height - cropHeight);
    const off = document.createElement('canvas');
    off.width = cropWidth;
    off.height = cropHeight;
    const ctx = off.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(canvas, sx, sy, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
    const potHeight = Math.round(14 * dpr);
    const potWidth = Math.min(cropWidth - Math.round(6 * dpr), Math.round(32 * dpr));
    const potX = Math.round((cropWidth - potWidth) / 2);
    const potY = cropHeight - potHeight;
    ctx.fillStyle = "#c26a2b";
    ctx.fillRect(potX, potY, potWidth, potHeight);
    ctx.fillStyle = "#a24f1b";
    ctx.fillRect(potX, potY + potHeight - Math.round(5 * dpr), potWidth, Math.round(5 * dpr));
    ctx.fillStyle = "rgba(59,47,38,0.55)";
    ctx.fillRect(potX + Math.round(3 * dpr), potY - Math.round(5 * dpr), potWidth - Math.round(6 * dpr), Math.round(6 * dpr));
    return { url: off.toDataURL("image/png"), width: cropWidth, height: cropHeight };
  }

  function makeMiniSnapshot(colorIdx, shapeIdx, target) {
    const stem = Math.round(22 + Math.min(32, (target || 1) * 1.1));
    const leavesOpacity = target >= 6 ? 1 : 0.72;
    const spriteFull = capturePlantSnapshot();
    return {
      colorIdx: clampColorIdx(colorIdx),
      shapeIdx,
      stem,
      leavesOpacity,
      sprite: createFlowerSprite(shapeIdx, colorIdx),
      spriteFull: spriteFull || null
    };
  }

    function addSparkles(el) {
      const offsets = [
        { x: -14, y: -6 },
        { x: 14, y: -2 },
        { x: 0, y: -16 }
      ];
      offsets.forEach((pos, idx) => {
        const sparkle = document.createElement("span");
        sparkle.className = `sparkle sparkle-${idx}`;
        sparkle.style.setProperty("--sparkle-x", `${pos.x}px`);
        sparkle.style.setProperty("--sparkle-y", `${pos.y}px`);
        el.appendChild(sparkle);
        setTimeout(() => sparkle.remove(), 900);
      });
    }

    function updateFlowerShelf(popIndex = -1) {
      const shelf = document.getElementById("flowerShelf");
      if (!shelf) return;
      shelf.innerHTML = "";
      const completed = Array.isArray(state.plant?.completed) ? state.plant.completed : [];
      completed.forEach((snap, idx) => {
        const info = normalizeSnapshot(snap);
        if (!info) return;
        const el = document.createElement("div");
        el.className = "mini-plant";
        el.style.setProperty("--mini-stem", PLANT_COLORS.stem);
        el.style.setProperty("--mini-leaf", PLANT_COLORS.leaf);
        el.style.setProperty("--mini-stem-height", `${info.stem}px`);
        el.style.setProperty("--mini-leaf-opacity", `${info.leavesOpacity}`);

        const stem = document.createElement("span");
        stem.className = "mini-stem";
        const leafL = document.createElement("span");
        leafL.className = "mini-leaf left";
        const leafR = document.createElement("span");
        leafR.className = "mini-leaf right";
        const pot = document.createElement("span");
        pot.className = "mini-pot";
        if (info.spriteFull?.url) {
          el.classList.add("has-sprite");
          const img = document.createElement("img");
          img.className = "mini-plant-sprite";
          img.src = info.spriteFull.url;
          img.alt = "Completed plant";
          img.width = info.spriteFull.width || 46;
          img.height = info.spriteFull.height || 72;
          img.style.width = "46px";
          img.style.height = "auto";
          el.appendChild(img);
        } else {
          const img = document.createElement("img");
          img.className = "mini-plant-sprite";
          img.alt = "Completed flower";
          if (info.sprite?.url) {
            img.src = info.sprite.url;
            img.width = info.sprite.size;
            img.height = info.sprite.size;
            const scale = Math.max(18, info.sprite.size * 4);
            img.style.width = `${scale}px`;
            img.style.height = `${scale}px`;
          }
          el.append(stem, leafL, leafR, img, pot);
        }

        if (idx === popIndex) {
          el.classList.add("pop");
          addSparkles(el);
          setTimeout(() => el.classList.remove("pop"), 700);
        }
        shelf.appendChild(el);
      });
    }

    function finalizeBloom() {
      if (!state.plant) return;
      const shapeIdx = getCurrentShapeIdx();
      const colorIdx = clampColorIdx(state.plant.colorIdx);
      const snapshot = makeMiniSnapshot(colorIdx, shapeIdx, state.plant.target);
      state.plant.completed = Array.isArray(state.plant.completed) ? state.plant.completed : [];
      state.plant.completed.push(snapshot);
      if (state.plant.completed.length > PLANT_LIMITS.maxShelf) state.plant.completed = state.plant.completed.slice(-PLANT_LIMITS.maxShelf);
      state.plant.colorIdx = clampColorIdx(colorIdx + 1);
      updateFlowerShelf(state.plant.completed.length - 1);
    }

    function advanceSentence() {
      if (!state.plant) return;
      const sentences = state.plant.sentences || [];
      state.plant.sentenceIdx += 1;
      state.plant.progress = 0;
      state.plant.target = Math.max(1, sentences[state.plant.sentenceIdx] || 1);
      state.plant.pendingBloom = false;
      const prevEnd = state.sentenceEnds?.[state.plant.sentenceIdx - 1];
      if (prevEnd != null) {
        state.plant.wordsSeen = Math.max(state.plant.wordsSeen || 0, prevEnd + 1);
      } else {
        state.plant.wordsSeen = Math.max(state.plant.wordsSeen || 0, state.lastProgressIndex + 1);
      }
      savePlantState();
      drawPlantRibbon();
    }

    function ensureFinalBloom() {
      if (!state.plant) return;
      if (state.plant.sentenceIdx >= (state.plant.sentences?.length || 0)) return;
      finalizeBloom();
      state.plant.sentenceIdx = state.plant.sentences.length;
      state.plant.progress = 0;
      state.plant.target = 1;
      state.plant.pendingBloom = false;
      state.plant.wordsSeen = state.tokens.length;
      savePlantState();
      drawPlantRibbon();
    }

    function recordWordProgress(wordIdx) {
      if (!state.plant || !state.tokens.length) return;
      if (wordIdx == null || wordIdx < 0) return;
      if (wordIdx <= state.lastProgressIndex || state.plant.pendingBloom) {
        if (wordIdx >= state.tokens.length - 1) ensureFinalBloom();
        return;
      }
      state.lastProgressIndex = wordIdx;
      state.plant.wordsSeen = Math.max(state.plant.wordsSeen || 0, wordIdx + 1);
      state.plant.progress = Math.max(0, (state.plant.progress || 0) + 1);
      drawPlantRibbon();

      const currentEnd = state.sentenceEnds?.[state.plant.sentenceIdx] ?? (state.tokens.length - 1);
      if (wordIdx >= currentEnd) {
        state.plant.pendingBloom = true;
        state.plant.progress = Math.max(1, state.plant.target);
        state.plant.wordsSeen = Math.max(state.plant.wordsSeen || 0, currentEnd + 1);
        drawPlantRibbon();
        setTimeout(() => {
          finalizeBloom();
          advanceSentence();
        }, 140);
      } else {
        savePlantState();
      }
      if (wordIdx >= state.tokens.length - 1) {
        setTimeout(() => ensureFinalBloom(), 200);
      }
    }

    function drawPlantRibbon() {
      const cv = document.getElementById('plantCanvas'); if (!cv) return;
      const ctx = cv.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const cell = 6;
      const width = cv.width / dpr;
      const height = cv.height / dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, cv.width, cv.height);
      ctx.scale(dpr, dpr);

      const centerX = Math.floor((width / 2) / cell) * cell;
      const stemBaseY = height - 32;

      ctx.fillStyle = PLANT_COLORS.seed1; ctx.fillRect(centerX - 6, stemBaseY + 12, cell, cell);
      ctx.fillStyle = PLANT_COLORS.seed2; ctx.fillRect(centerX, stemBaseY + 12, cell, cell);

      if (!state.plant) return;

      const target = Math.max(1, state.plant.target || 1);
      const progress = Math.max(0, Math.min(state.plant.progress || 0, target));
      const ratio = target ? Math.min(1, progress / target) : 0;
      const maxSegments = Math.max(4, 6 + target);
      let filledSegments = Math.round(maxSegments * ratio);
      if (ratio > 0 && filledSegments === 0) filledSegments = 1;

      ctx.fillStyle = PLANT_COLORS.stem;
      for (let i = 0; i < filledSegments; i++) {
        const y = stemBaseY - i * cell;
        ctx.fillRect(centerX, y, cell, cell);
        if (i % 3 === 1) {
          ctx.fillStyle = PLANT_COLORS.leaf;
          ctx.fillRect(centerX - cell, y, cell, cell);
          ctx.fillStyle = PLANT_COLORS.stem;
        }
        if (i % 4 === 2) {
          ctx.fillStyle = PLANT_COLORS.leaf;
          ctx.fillRect(centerX + cell, y - cell, cell, cell);
          ctx.fillStyle = PLANT_COLORS.stem;
        }
      }

      const colorIdx = clampColorIdx(state.plant.colorIdx);
      const flowerColor = PLANT_COLORS.flowers[colorIdx] || PLANT_COLORS.bud;

      if (ratio >= 1 && filledSegments > 0) {
        const centerY = stemBaseY - filledSegments * cell - cell;
        drawShapePixels(ctx, centerX, centerY, cell, getCurrentShapeIdx(), flowerColor);
      } else if (filledSegments > 0) {
        const budY = stemBaseY - filledSegments * cell - cell;
        ctx.fillStyle = flowerColor;
        ctx.fillRect(centerX, budY, cell, cell);
      }
    }

    function resizePlantCanvas() {
      const cv = document.getElementById('plantCanvas'); if (!cv) return;
      const dock = document.getElementById('plantDock');
      const rect = dock?.getBoundingClientRect();
      const cssW = Math.max(48, Math.floor((rect?.width || 56)));
      const cssH = Math.max(220, Math.floor(window.innerHeight - 48));
      const dpr = window.devicePixelRatio || 1;
      cv.style.width = cssW + 'px';
      cv.style.height = cssH + 'px';
      cv.width = Math.round(cssW * dpr);
      cv.height = Math.round(cssH * dpr);
    }
    // redraw on resize
    window.addEventListener('resize', () => { resizePlantCanvas(); drawPlantRibbon(); });

  </script>
</body>

</html>
